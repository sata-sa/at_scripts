#!/usr/bin/perl -w

use strict;

#sub backwards ($$) { $_[1] cmp $_[0]; }

use Data::Dumper;

my $in = 0;
my %THREADS = ();
my %THREADN = (); #thread names {pos}->{name}
my @HTMLRULESET;
my %LOCK;
my %WAIT;

#DEFAULTS
my $version    = '0.0.7';
my $script_nm  = 'thread_analyzer.pl';
my $dir_shared = '/home/weblogic/etc/wlInterrogator/thread_analyzer';
my $htmlrsfile = $dir_shared.'/thread_analyzer.rs'; #ruleset file to beautify html
#my $directory  = '/opt/stage/thread_dumps/diag/threads'; #directory to store threads
my $directory  = $ARGV[0]; #directory to store threads
my $threads_log = $ARGV[1];

sub load_htmlruleset
{
  my ($filename) = @_;

  unless (-f $filename)
  {
    warn 'No ruleset specified';
    return;
  }

  open (H, $filename);

  while (<H>)
  {
    next if /^#|^(\ +)?$/;
    chomp;
    push @HTMLRULESET, $_;
  }
  close H;
}

#wrap table around a thread
sub html_thread
{
  my ($thread_name, $text, $anchor, $links) = @_;
  my $thread_title  = '<a name="'.$anchor.'"></a>'.$THREADS{$thread_name}->{name};
  chomp $thread_title;
  $links = "[<a href=\"#top\">top</a>] [<a href=\"javascript:open_win('$directory/$anchor');\">transpose</a>]" unless $links;
  return 
    "
     <table>
       <tr><td colspan=2><table><tr><td><h2>$thread_title</h2></td><td align=right valign=bottom>$links</td></tr></table></td></tr>
       <tr><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td><table class=thread_landscape>$text</table></td></tr>
     </table>
    ";
}

sub beautify
{
  my ($text) = @_;
  no strict;

  for my $regexp (@HTMLRULESET)
  {
    eval( '$text =~ '.$regexp.';' );
  }

  use strict;
  return $text;
}

#cssize the threads' text
sub parse_thread
{
  my ($thread) = @_;
  $thread = "<pre>$thread</pre>";
  $thread = beautify($thread);
  return $thread;
}

#process() -> processes thread dump blocks
sub parse
{
  return unless $_;
  #"[STANDBY] ExecuteThread: '52' for queue: 'weblogic.kernel.Default (self-tuning)'" waiting for lock weblogic.work.ExecuteThread@8dccd3 WAITING
  s/^\[[A-Z_]+\]\ +(.*)/$1/g;
  my $thread_name = $1 if (/^\"(.+)\"\ /);

  unless ($thread_name)
  {
    if (/(Thread t\@.+)?:/)
    {
      $thread_name = $1;
    }
  }
  return unless $thread_name;

  #print STDERR "+++++++++++++++++++++++++++++++\n$_\n+++++++++++++++++++++++++++++++\n$thread_name\n";
  #"ExecuteThread: '2' for queue: 'weblogic.socket.Muxer'" daemon prio=1 tid=0xb0908030 nid=0x4427 waiting for monitor entry [b8dbd000..b8dbd8c8]
  #/export/home/weblogic/bin/wlInterrogator/bin/thread_analyzer.pl.20090616
  #"[STANDBY] ExecuteThread: '37' for queue: 'weblogic.kernel.Default (self-tuning)'" waiting for lock weblogic.work.ExecuteThread@1d2b2 WAITING
  #"Timer-5" waiting for lock java.util.TaskQueue@ff239c TIMED_WAITING
  if (0)
  {
  }
  elsif (/(Thread t\@.+)?:\ +\(state\ =\ (.*)?\)/)
  {
    push @{$THREADS{$thread_name}->{state}}, $2;
  }
  elsif (/=[0-9a-fx]+\ ([a-z \(\).]+)\ ?(\[([0-9a-fx]+)\.\.([0-9a-fx]+)\])?\n/i)
  {
    push @{$THREADS{$thread_name}->{state}}, $1;
    $THREADS{$thread_name}->{mem_interval} = $2;
    $THREADS{$thread_name}->{mem_start}    = $3;
    $THREADS{$thread_name}->{mem_end}      = $4;
  }
  elsif (/.*\".*?(\@[a-fx0-9]+).*?([A-Z0-9_]+)/)
  {
    #atraves de wget ao yajpa
    push @{$THREADS{$thread_name}->{state}}, $2;
  }
  elsif (/RUNNABLE native/)
  {
    push @{$THREADS{$thread_name}->{state}}, "RUNNABLE";
  }
  elsif (/RUNNABLE/)
  {
    push @{$THREADS{$thread_name}->{state}}, "RUNNABLE";
    #"Thread-8" WAITING
  }
  elsif (/\"Thread-\d+\"\ +([A-Z0-9_]+)/)
  {
    push @{$THREADS{$thread_name}->{state}}, $1;
    #"org.grnds.foundation.cache.GrndsCache$CacheReaper.Thread" TIMED_WAITING
  }
  elsif (/\".*?\"\ +([A-Z_]+)/)
  {
    push @{$THREADS{$thread_name}->{state}}, $1;
  }
  else
  {
    push @{$THREADS{$thread_name}->{state}}, "UNABLE_TO_PARSE_THREAD_STATE";
  }
  #push @{$THREADS{$thread_name}->{waiting_on}} if (/waiting on <([0-9a-fx]+)>/);
  #push @{$THREADS{$thread_name}->{locked}}     if (/locked <([0-9a-fx]+)>/);
  $THREADS{$thread_name}->{name}  = $thread_name;
  push @{$THREADS{$thread_name}->{text}}, $_;
  $thread_name = "";
}

sub wrap_td
{
  my ($cell_content, $class) = @_;
  my $html = '<td valign=top class="'.$class.'">'.$cell_content.'</td>';

  return $html;
}

sub wrap_tr
{
  my ($row, $class) = @_;
  my $html  = '<tr class="'.$class.'">'.$row.'</tr>';

  return $html;
}

sub wrap_table
{
  my ($rows, $class) = @_;
  my $html  = '<table class="'.$class.'">'.$rows.'</table>';

  return $html;
}

sub html_footer
{
  return "
<center><span class=small>generated by thread analyzer version $version</span></center>
</body>
</html>
  ";
}

sub html_header
{
  open (H, $dir_shared.'/thread_analyzer.css');
  my $css = '';

  while (<H>)
  {
    $css .= $_;
  }
  close H;

  open (H, $dir_shared.'/thread_analyzer.js');
  my $js = '';

  while (<H>)
  {
    $js .= $_;
  }

  close H;
  return "
<html>

<head>
<title>Thread Dump Analyzer</title>
</head>
".$css."\n".$js."
<body>
<a name=\"top\"></a>
  ";
}

sub store_thread
{
  my ($text, $filename) = @_;
  `mkdir $directory` unless (-d $directory);
  $filename = $directory.'/'.$filename.'.html';
  my $header = html_header;
  my $footer = html_footer;
  open (TT, ">$filename") or die "ooops $!";
  print TT $header.$text.$footer;
  close TT;
}

#############
# MAIN LOOP #
#############
load_htmlruleset($htmlrsfile);

open(THREADSLOG, $threads_log) or die("Could not open file $threads_log.");

#Loads to memory the relevant thread dumps' info contained on the log
while (<THREADSLOG>)
{
  #typical thread dump
  #Full thread dump Java HotSpot(TM) Server VM (1.4.2_04-b05 mixed mode):
  $in = 1 if /^Full\ thread\ dump/;
  #"Suspend Checker Thread" prio=1 tid=0x080c57a8 nid=0x3ee7 runnable
  $in = 0 if /^\"Suspend\ Checker\ Thread/;

  #using yajpa:
  $in = 1 if /-com.bea:Name=.*?,ServerRuntime=.*?,Type=JVMRuntime/;
  $in = 0 if /\*Parent = com.bea:Name=/;

  #Attaching to process ID 7274, please wait...
  #Debugger attached successfully.
  #Server compiler detected.
  #JVM version is 1.5.0_11-b03
  $in = 2 if /Debugger attached successfully/;
  $in = 0 if /Attaching to process ID/;

  if ($in == 1)
  {
    $/ = "\n\n";
    parse;
  }
  elsif ($in == 2)
  {
    $/ = "\n\n";
    parse;
  }
  else
  {
    $/ = "\n";
  }
}

#generate HTML
my $html = '';
my $thread_index = '';
my $count = 0;

for my $thread_name (sort (keys %THREADS))
{
  my $thread_landscape = '';
  my $thread_portrait  = '';
  my $thread_html      = '';
  my $thread_state     = '';
  my $thread_state_seq = '';
  my $num_dumps = 0;
  my $thread_anchor = "t$count";

  for my $thread_text (@{$THREADS{$thread_name}->{text}})
  {
    my $dump_anchor    = "t$count-$num_dumps";
    my $dump_anchor_b  = "t$count-".($num_dumps - 1);
    my $dump_anchor_n  = "t$count-".($num_dumps + 1);
    my $navigation     = ' [<a href="#'.$thread_anchor.'">Up</a>] ';
    my $dump_html      = parse_thread($thread_text);
    $navigation       .= ($num_dumps)?' [<a href="#'.$dump_anchor_b.'">Previous</a>] ':'[Previous]';
    $navigation       .= ($#{@{$THREADS{$thread_name}->{text}}} > ($num_dumps))?' [<a href="#'.$dump_anchor_n.'">Next</a>] ':'[Next]';
    my $tstate         = '<a name="'.$dump_anchor.'"></a>'.
                         '<b>Dump '.($num_dumps+1).' '.$navigation.' '.
                         '<br>State: '.
                         beautify(@{$THREADS{$thread_name}->{state}}[$num_dumps]).
                         '';
    my $dstate         = @{$THREADS{$thread_name}->{state}}[$num_dumps];
    $thread_state     .= "\n  ".wrap_td($tstate, 'thread_style');
    $thread_landscape .= wrap_td($dump_html, 'thread_style');
    $thread_portrait  .= wrap_tr(wrap_td($tstate, 'thread_style'), 'thread_style');
    $thread_portrait  .= wrap_tr(wrap_td($dump_html, 'thread_style'),'thread_style');
    my $dlink = beautify('<a href="#'.$dump_anchor.'" class=thread_state_small>'.$dstate).'</a>';
    @{$THREADS{$thread_name}->{state_links}}[$num_dumps] = $dlink;
    my $temp_text = $thread_text;

    while ($temp_text =~ s/locked <([0-9a-fx]+)>//i)
    {
      my $locked_object  = $1;
      ${%{$LOCK{$num_dumps}}}{$locked_object}   = $count     if $locked_object;
    }

    while ($temp_text =~ s/waiting to lock <([0-9a-fx]+)>//i)
    {
      my $waiting_object  = $1;
      push @{${%{$WAIT{$num_dumps}}}{$waiting_object}}, $count if $waiting_object;
    }

    while ($temp_text =~ s/waiting for lock <([0-9a-fx]+)>//i)
    {
      my $waiting_object  = $1;
      push @{${%{$WAIT{$num_dumps}}}{$waiting_object}}, $count if $waiting_object;
    }

    $num_dumps++;
  }
  $THREADN{$count}  = $thread_name;
  $thread_state_seq = join ' -&gt; ', @{$THREADS{$thread_name}->{state_links}};

  $thread_index    .= '<li><b>'.$count.'.</b> <a href="#'.$thread_anchor.'">'.$THREADS{$thread_name}->{name}.'</a> ('.$num_dumps.' Dumps)<br>'.
                      '<span class=thread_state_small>&nbsp;&nbsp;'.$thread_state_seq.'</span>';
  $thread_html     .= wrap_tr($thread_state,'thread_style');
  $thread_html     .= wrap_tr($thread_landscape,'thread_style');
  $thread_portrait  = html_thread($thread_name, wrap_table($thread_portrait,'thread_style'), $thread_anchor, '[<a href="javascript:close();">close</a>]');
  $thread_landscape = html_thread($thread_name, $thread_html, $thread_anchor);
  $html            .= $thread_landscape;
  $count++;
  store_thread($thread_portrait, $thread_anchor);
}

my $locks = "";

for my $num_dump (sort keys %WAIT)
{
  for my $obj_id (keys %{$WAIT{$num_dump}})
  {
    my $svg;# = svg_head;
    my $thread_names = '';
    my $wait_num     = 0;

    for my $thread_number (@{${%{$WAIT{$num_dump}}}{$obj_id}})
    {
      my $thread_name  = $THREADN{$thread_number};
      next unless $thread_name;
      my @thread_lines = split /\n/, ${@{$THREADS{$thread_name}->{text}}}[$num_dump];
      $thread_names   .= '<a href="#t'.$thread_number.'-'.$num_dump.'" class=thread_state_small_y>'.
                         $THREADN{$thread_number}.
                         '</a>, ';
      $wait_num++;
    }

    chop $thread_names;
    chop $thread_names;
      $locks .= "<br><li><b>Dump ".($num_dump + 1)."</b>:".
                " Threads $thread_names are waiting for object <span class=object>$obj_id</span>".
                " which is locked by thread ".
                "<b>".'<a href="#t'.${%{$LOCK{$num_dump}}}{$obj_id}.'-'.$num_dump.'" class=thread_state_small_r>'.$THREADN{${%{$LOCK{$num_dump}}}{$obj_id}}."</a></b>"."\n" if (${%{$LOCK{$num_dump}}}{$obj_id})
  }
}

use POSIX qw(strftime);
my $now_string = strftime "%a %b %e %H:%M:%S %Y", localtime;

print html_header;
print 
"
<table cellpadding=0 cellspacing=0 border=0>
<tr>
<td><h2>Thread analysis</h2></td>
<td valign=bottom>&nbsp;&nbsp;<b>$now_string</b></td>
</tr>
</table>
<ol>
<li><a href=#tindex>Thread index</a>
<li><a href=#tlocks>Locks</a>
<li><a href=#tbegin>Begin of thread dump</a>
</ol>
";
print "<a name=tindex></a><h2>Thread Index</h2>";
print '<ul>';
print $thread_index;
print '</ul>';
print "<a name=tlocks></a><h2>Locks</h2>";
print "<ul>".$locks."</ul>";
print "<a name=tbegin></a><h2>Begin of Thread Analysis</h2>";
print $html;
print html_footer;

